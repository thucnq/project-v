// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: read_sla.sql

package sqlc

import (
	"context"
)

const countDefaultSlaByWorkspaceID = `-- name: CountDefaultSlaByWorkspaceID :one
SELECT COUNT(*)
FROM slas s1
WHERE s1.workspace_id = ?
    AND s1.is_default = true
    AND s1.is_deleted = false
    AND version = (SELECT MAX(version)
                 FROM slas s2
                 WHERE s1.workspace_id = s2.workspace_id
                   AND s1.id = s2.id)
`

func (q *Queries) CountDefaultSlaByWorkspaceID(ctx context.Context, workspaceID string) (int64, error) {
	row := q.queryRow(ctx, q.countDefaultSlaByWorkspaceIDStmt, countDefaultSlaByWorkspaceID, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countExistedNameSlaByWorkspaceID = `-- name: CountExistedNameSlaByWorkspaceID :one
SELECT COUNT(*)
FROM slas s1
WHERE s1.workspace_id = ?
  AND s1.id != ?
  AND s1.is_deleted = false
  AND version = (SELECT MAX(version)
                 FROM slas s2
                 WHERE s1.workspace_id = s2.workspace_id
                   AND s1.id = s2.id)
  AND s1.name = ?
`

type CountExistedNameSlaByWorkspaceIDParams struct {
	WorkspaceID string
	ID          int64
	Name        string
}

func (q *Queries) CountExistedNameSlaByWorkspaceID(ctx context.Context, arg CountExistedNameSlaByWorkspaceIDParams) (int64, error) {
	row := q.queryRow(ctx, q.countExistedNameSlaByWorkspaceIDStmt, countExistedNameSlaByWorkspaceID, arg.WorkspaceID, arg.ID, arg.Name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSlas = `-- name: CountSlas :one
SELECT COUNT(*)
FROM slas s1
WHERE s1.workspace_id = ?
  AND version = (SELECT MAX(version)
                 FROM slas s2
                 WHERE s1.workspace_id = s2.workspace_id
                   AND s1.id = s2.id)
  AND is_deleted = false
  AND ((? = 0) OR (s1.status = ? AND ? = 1) OR (s1.status = ? AND ? = 2))
  AND ((? = '') OR (s1.name LIKE ?))
`

type CountSlasParams struct {
	WorkspaceID string
	Column2     interface{}
	Status      int8
	Column4     interface{}
	Status_2    int8
	Column6     interface{}
	Column7     interface{}
	Name        string
}

func (q *Queries) CountSlas(ctx context.Context, arg CountSlasParams) (int64, error) {
	row := q.queryRow(ctx, q.countSlasStmt, countSlas,
		arg.WorkspaceID,
		arg.Column2,
		arg.Status,
		arg.Column4,
		arg.Status_2,
		arg.Column6,
		arg.Column7,
		arg.Name,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllSlas = `-- name: GetAllSlas :many
SELECT workspace_id, id, name, shift_id, is_default, status, sla_priority_levels, sla_notifications, version, is_deleted, created_by, updated_by, created_at, updated_at
FROM slas s1
WHERE s1.workspace_id = ?
    AND version = (SELECT MAX(version)
                    FROM slas s2
                    WHERE s1.workspace_id = s2.workspace_id
                    AND s1.id = s2.id)
  AND is_deleted = false
ORDER BY s1.id DESC
`

func (q *Queries) GetAllSlas(ctx context.Context, workspaceID string) ([]Sla, error) {
	rows, err := q.query(ctx, q.getAllSlasStmt, getAllSlas, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sla
	for rows.Next() {
		var i Sla
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.Name,
			&i.ShiftID,
			&i.IsDefault,
			&i.Status,
			&i.SlaPriorityLevels,
			&i.SlaNotifications,
			&i.Version,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSlasPaging = `-- name: GetAllSlasPaging :many
SELECT workspace_id, id, name, shift_id, is_default, status, sla_priority_levels, sla_notifications, version, is_deleted, created_by, updated_by, created_at, updated_at
FROM slas s1
WHERE s1.workspace_id = ?
  AND version = (SELECT MAX(version)
                 FROM slas s2
                 WHERE s1.workspace_id = s2.workspace_id
                   AND s1.id = s2.id)
  AND is_deleted = false
  AND ((? = 0) OR (s1.status = ? AND ? = 1) OR (s1.status = ? AND ? = 2))
  AND ((? = '') OR (s1.name LIKE ?))
  AND s1.id != ?
ORDER BY s1.id DESC
LIMIT ?
`

type GetAllSlasPagingParams struct {
	WorkspaceID string
	Column2     interface{}
	Status      int8
	Column4     interface{}
	Status_2    int8
	Column6     interface{}
	Column7     interface{}
	Name        string
	ID          int64
	Limit       int32
}

func (q *Queries) GetAllSlasPaging(ctx context.Context, arg GetAllSlasPagingParams) ([]Sla, error) {
	rows, err := q.query(ctx, q.getAllSlasPagingStmt, getAllSlasPaging,
		arg.WorkspaceID,
		arg.Column2,
		arg.Status,
		arg.Column4,
		arg.Status_2,
		arg.Column6,
		arg.Column7,
		arg.Name,
		arg.ID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sla
	for rows.Next() {
		var i Sla
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.Name,
			&i.ShiftID,
			&i.IsDefault,
			&i.Status,
			&i.SlaPriorityLevels,
			&i.SlaNotifications,
			&i.Version,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSlasPagingNext = `-- name: GetAllSlasPagingNext :many
SELECT workspace_id, id, name, shift_id, is_default, status, sla_priority_levels, sla_notifications, version, is_deleted, created_by, updated_by, created_at, updated_at
FROM slas s1
WHERE s1.workspace_id = ?
  AND version = (SELECT MAX(version)
                 FROM slas s2
                 WHERE s1.workspace_id = s2.workspace_id
                   AND s1.id = s2.id)
  AND is_deleted = false
  AND ((? = 0) OR (s1.status = ? AND ? = 1) OR (s1.status = ? AND ? = 2))
  AND ((? = '') OR (s1.name LIKE ?))
  AND s1.id < ?
  AND s1.id != ?
ORDER BY s1.id DESC
LIMIT ?
`

type GetAllSlasPagingNextParams struct {
	WorkspaceID string
	Column2     interface{}
	Status      int8
	Column4     interface{}
	Status_2    int8
	Column6     interface{}
	Column7     interface{}
	Name        string
	ID          int64
	ID_2        int64
	Limit       int32
}

func (q *Queries) GetAllSlasPagingNext(ctx context.Context, arg GetAllSlasPagingNextParams) ([]Sla, error) {
	rows, err := q.query(ctx, q.getAllSlasPagingNextStmt, getAllSlasPagingNext,
		arg.WorkspaceID,
		arg.Column2,
		arg.Status,
		arg.Column4,
		arg.Status_2,
		arg.Column6,
		arg.Column7,
		arg.Name,
		arg.ID,
		arg.ID_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sla
	for rows.Next() {
		var i Sla
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.Name,
			&i.ShiftID,
			&i.IsDefault,
			&i.Status,
			&i.SlaPriorityLevels,
			&i.SlaNotifications,
			&i.Version,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSlasPagingPrev = `-- name: GetAllSlasPagingPrev :many
SELECT workspace_id, id, name, shift_id, is_default, status, sla_priority_levels, sla_notifications, version, is_deleted, created_by, updated_by, created_at, updated_at
FROM slas s1
WHERE s1.workspace_id = ?
  AND version = (SELECT MAX(version)
                 FROM slas s2
                 WHERE s1.workspace_id = s2.workspace_id
                   AND s1.id = s2.id)
  AND is_deleted = false
  AND ((? = 0) OR (s1.status = ? AND ? = 1) OR (s1.status = ? AND ? = 2))
  AND ((? = '') OR (s1.name LIKE ?))
  AND s1.id > ?
  AND s1.id != ?
ORDER BY s1.id ASC
LIMIT ?
`

type GetAllSlasPagingPrevParams struct {
	WorkspaceID string
	Column2     interface{}
	Status      int8
	Column4     interface{}
	Status_2    int8
	Column6     interface{}
	Column7     interface{}
	Name        string
	ID          int64
	ID_2        int64
	Limit       int32
}

func (q *Queries) GetAllSlasPagingPrev(ctx context.Context, arg GetAllSlasPagingPrevParams) ([]Sla, error) {
	rows, err := q.query(ctx, q.getAllSlasPagingPrevStmt, getAllSlasPagingPrev,
		arg.WorkspaceID,
		arg.Column2,
		arg.Status,
		arg.Column4,
		arg.Status_2,
		arg.Column6,
		arg.Column7,
		arg.Name,
		arg.ID,
		arg.ID_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sla
	for rows.Next() {
		var i Sla
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.Name,
			&i.ShiftID,
			&i.IsDefault,
			&i.Status,
			&i.SlaPriorityLevels,
			&i.SlaNotifications,
			&i.Version,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDefaultSla = `-- name: GetDefaultSla :one
SELECT workspace_id, id, name, shift_id, is_default, status, sla_priority_levels, sla_notifications, version, is_deleted, created_by, updated_by, created_at, updated_at
FROM slas
WHERE workspace_id = ?
  AND is_default = true
ORDER BY version DESC
LIMIT 1
`

func (q *Queries) GetDefaultSla(ctx context.Context, workspaceID string) (Sla, error) {
	row := q.queryRow(ctx, q.getDefaultSlaStmt, getDefaultSla, workspaceID)
	var i Sla
	err := row.Scan(
		&i.WorkspaceID,
		&i.ID,
		&i.Name,
		&i.ShiftID,
		&i.IsDefault,
		&i.Status,
		&i.SlaPriorityLevels,
		&i.SlaNotifications,
		&i.Version,
		&i.IsDeleted,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDefaultSlaByFilter = `-- name: GetDefaultSlaByFilter :one
SELECT workspace_id, id, name, shift_id, is_default, status, sla_priority_levels, sla_notifications, version, is_deleted, created_by, updated_by, created_at, updated_at
FROM slas s1
WHERE s1.workspace_id = ?
  AND version = (SELECT MAX(version)
                 FROM slas s2
                 WHERE s1.workspace_id = s2.workspace_id
                   AND s1.id = s2.id)
  AND is_deleted = false
  AND ((? = 0) OR (s1.status = ? AND ? = 1) OR (s1.status = ? AND ? = 2))
  AND ((? = '') OR (s1.name LIKE ?))
  AND is_default = true
LIMIT 1
`

type GetDefaultSlaByFilterParams struct {
	WorkspaceID string
	Column2     interface{}
	Status      int8
	Column4     interface{}
	Status_2    int8
	Column6     interface{}
	Column7     interface{}
	Name        string
}

func (q *Queries) GetDefaultSlaByFilter(ctx context.Context, arg GetDefaultSlaByFilterParams) (Sla, error) {
	row := q.queryRow(ctx, q.getDefaultSlaByFilterStmt, getDefaultSlaByFilter,
		arg.WorkspaceID,
		arg.Column2,
		arg.Status,
		arg.Column4,
		arg.Status_2,
		arg.Column6,
		arg.Column7,
		arg.Name,
	)
	var i Sla
	err := row.Scan(
		&i.WorkspaceID,
		&i.ID,
		&i.Name,
		&i.ShiftID,
		&i.IsDefault,
		&i.Status,
		&i.SlaPriorityLevels,
		&i.SlaNotifications,
		&i.Version,
		&i.IsDeleted,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSlaByID = `-- name: GetSlaByID :one
SELECT workspace_id, id, name, shift_id, is_default, status, sla_priority_levels, sla_notifications, version, is_deleted, created_by, updated_by, created_at, updated_at
FROM slas
WHERE workspace_id = ?
  AND id = ?
ORDER BY version DESC
LIMIT 1
`

type GetSlaByIDParams struct {
	WorkspaceID string
	ID          int64
}

func (q *Queries) GetSlaByID(ctx context.Context, arg GetSlaByIDParams) (Sla, error) {
	row := q.queryRow(ctx, q.getSlaByIDStmt, getSlaByID, arg.WorkspaceID, arg.ID)
	var i Sla
	err := row.Scan(
		&i.WorkspaceID,
		&i.ID,
		&i.Name,
		&i.ShiftID,
		&i.IsDefault,
		&i.Status,
		&i.SlaPriorityLevels,
		&i.SlaNotifications,
		&i.Version,
		&i.IsDeleted,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSlasByShiftID = `-- name: GetSlasByShiftID :many
SELECT workspace_id, id, name, shift_id, is_default, status, sla_priority_levels, sla_notifications, version, is_deleted, created_by, updated_by, created_at, updated_at
FROM slas s1
WHERE s1.workspace_id = ?
  AND s1.shift_id = ?
  AND is_deleted = false
  AND version = (SELECT MAX(version)
                 FROM slas s2
                 WHERE s1.workspace_id = s2.workspace_id
                   AND s1.id = s2.id)
`

type GetSlasByShiftIDParams struct {
	WorkspaceID string
	ShiftID     int64
}

func (q *Queries) GetSlasByShiftID(ctx context.Context, arg GetSlasByShiftIDParams) ([]Sla, error) {
	rows, err := q.query(ctx, q.getSlasByShiftIDStmt, getSlasByShiftID, arg.WorkspaceID, arg.ShiftID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sla
	for rows.Next() {
		var i Sla
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.Name,
			&i.ShiftID,
			&i.IsDefault,
			&i.Status,
			&i.SlaPriorityLevels,
			&i.SlaNotifications,
			&i.Version,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockSlasByWorkspaceIDForUpdate = `-- name: LockSlasByWorkspaceIDForUpdate :many
SELECT workspace_id, id, name, shift_id, is_default, status, sla_priority_levels, sla_notifications, version, is_deleted, created_by, updated_by, created_at, updated_at
FROM slas
WHERE workspace_id = ? FOR UPDATE
`

func (q *Queries) LockSlasByWorkspaceIDForUpdate(ctx context.Context, workspaceID string) ([]Sla, error) {
	rows, err := q.query(ctx, q.lockSlasByWorkspaceIDForUpdateStmt, lockSlasByWorkspaceIDForUpdate, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sla
	for rows.Next() {
		var i Sla
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.Name,
			&i.ShiftID,
			&i.IsDefault,
			&i.Status,
			&i.SlaPriorityLevels,
			&i.SlaNotifications,
			&i.Version,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
