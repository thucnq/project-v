// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: read_ticket_node_participant.sql

package sqlc

import (
	"context"
	"strings"
)

const getTicketNodeParticipantByRoleAndType = `-- name: GetTicketNodeParticipantByRoleAndType :one
SELECT workspace_id, ticket_id, node_id, participant_id, role_type, participant_type, created_at, updated_at
FROM ticket_node_participants
WHERE workspace_id = ? AND ticket_id = ? AND node_id = ? AND role_type = ? AND participant_type = ?
LIMIT 1
`

type GetTicketNodeParticipantByRoleAndTypeParams struct {
	WorkspaceID     string
	TicketID        int64
	NodeID          int64
	RoleType        int8
	ParticipantType int8
}

func (q *Queries) GetTicketNodeParticipantByRoleAndType(ctx context.Context, arg GetTicketNodeParticipantByRoleAndTypeParams) (TicketNodeParticipant, error) {
	row := q.queryRow(ctx, q.getTicketNodeParticipantByRoleAndTypeStmt, getTicketNodeParticipantByRoleAndType,
		arg.WorkspaceID,
		arg.TicketID,
		arg.NodeID,
		arg.RoleType,
		arg.ParticipantType,
	)
	var i TicketNodeParticipant
	err := row.Scan(
		&i.WorkspaceID,
		&i.TicketID,
		&i.NodeID,
		&i.ParticipantID,
		&i.RoleType,
		&i.ParticipantType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listTicketNodeParticipantsByNodeID = `-- name: ListTicketNodeParticipantsByNodeID :many
SELECT workspace_id, ticket_id, node_id, participant_id, role_type, participant_type, created_at, updated_at
FROM ticket_node_participants
WHERE workspace_id = ? AND ticket_id = ? AND node_id = ?
`

type ListTicketNodeParticipantsByNodeIDParams struct {
	WorkspaceID string
	TicketID    int64
	NodeID      int64
}

func (q *Queries) ListTicketNodeParticipantsByNodeID(ctx context.Context, arg ListTicketNodeParticipantsByNodeIDParams) ([]TicketNodeParticipant, error) {
	rows, err := q.query(ctx, q.listTicketNodeParticipantsByNodeIDStmt, listTicketNodeParticipantsByNodeID, arg.WorkspaceID, arg.TicketID, arg.NodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TicketNodeParticipant
	for rows.Next() {
		var i TicketNodeParticipant
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.TicketID,
			&i.NodeID,
			&i.ParticipantID,
			&i.RoleType,
			&i.ParticipantType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTicketRoles = `-- name: ListUserTicketRoles :many
SELECT np.role_type,  np.participant_type, np.node_id
FROM ticket_node_participants np
         INNER JOIN participant_members pm ON np.participant_id = pm.participant_id
WHERE np.workspace_id= ? AND np.node_id IN (/*SLICE:node_ids*/?) AND pm.user_id = ?
`

type ListUserTicketRolesParams struct {
	WorkspaceID string
	NodeIds     []int64
	UserID      int64
}

type ListUserTicketRolesRow struct {
	RoleType        int8
	ParticipantType int8
	NodeID          int64
}

func (q *Queries) ListUserTicketRoles(ctx context.Context, arg ListUserTicketRolesParams) ([]ListUserTicketRolesRow, error) {
	query := listUserTicketRoles
	var queryParams []interface{}
	queryParams = append(queryParams, arg.WorkspaceID)
	if len(arg.NodeIds) > 0 {
		for _, v := range arg.NodeIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:node_ids*/?", strings.Repeat(",?", len(arg.NodeIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:node_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UserID)
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserTicketRolesRow
	for rows.Next() {
		var i ListUserTicketRolesRow
		if err := rows.Scan(&i.RoleType, &i.ParticipantType, &i.NodeID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
