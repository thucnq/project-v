// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: read_unfollow.sql

package sqlc

import (
	"context"
)

const countUnfollow = `-- name: CountUnfollow :one
SELECT COUNT(*)
FROM unfollows
WHERE workspace_id = ?
  AND ticket_id = ?
  AND user_id = ?
`

type CountUnfollowParams struct {
	WorkspaceID string
	TicketID    int64
	UserID      int64
}

func (q *Queries) CountUnfollow(ctx context.Context, arg CountUnfollowParams) (int64, error) {
	row := q.queryRow(ctx, q.countUnfollowStmt, countUnfollow, arg.WorkspaceID, arg.TicketID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listUnfollowByUserID = `-- name: ListUnfollowByUserID :many
SELECT workspace_id, user_id, ticket_id
FROM unfollows
WHERE workspace_id = ?
  AND user_id = ?
`

type ListUnfollowByUserIDParams struct {
	WorkspaceID string
	UserID      int64
}

func (q *Queries) ListUnfollowByUserID(ctx context.Context, arg ListUnfollowByUserIDParams) ([]Unfollow, error) {
	rows, err := q.query(ctx, q.listUnfollowByUserIDStmt, listUnfollowByUserID, arg.WorkspaceID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unfollow
	for rows.Next() {
		var i Unfollow
		if err := rows.Scan(&i.WorkspaceID, &i.UserID, &i.TicketID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
