// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: read_workflow_group.sql

package sqlc

import (
	"context"
	"database/sql"
)

const getAllWorkflowGroups = `-- name: GetAllWorkflowGroups :many
SELECT workspace_id, id, parent_id, name, left_bower, right_bower, workflow_count, h_level, version, created_at, updated_at
FROM workflow_groups
WHERE workspace_id=? AND parent_id > 0
ORDER BY left_bower ASC
`

func (q *Queries) GetAllWorkflowGroups(ctx context.Context, workspaceID string) ([]WorkflowGroup, error) {
	rows, err := q.query(ctx, q.getAllWorkflowGroupsStmt, getAllWorkflowGroups, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowGroup
	for rows.Next() {
		var i WorkflowGroup
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.ParentID,
			&i.Name,
			&i.LeftBower,
			&i.RightBower,
			&i.WorkflowCount,
			&i.HLevel,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChildWorkflowGroups = `-- name: GetChildWorkflowGroups :many
SELECT workspace_id, id, parent_id, name, left_bower, right_bower, workflow_count, h_level, version, created_at, updated_at
FROM workflow_groups
WHERE workspace_id=? AND parent_id=?
ORDER BY left_bower ASC
`

type GetChildWorkflowGroupsParams struct {
	WorkspaceID string
	ParentID    int64
}

func (q *Queries) GetChildWorkflowGroups(ctx context.Context, arg GetChildWorkflowGroupsParams) ([]WorkflowGroup, error) {
	rows, err := q.query(ctx, q.getChildWorkflowGroupsStmt, getChildWorkflowGroups, arg.WorkspaceID, arg.ParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowGroup
	for rows.Next() {
		var i WorkflowGroup
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.ParentID,
			&i.Name,
			&i.LeftBower,
			&i.RightBower,
			&i.WorkflowCount,
			&i.HLevel,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullPathOfWorkflowGroup = `-- name: GetFullPathOfWorkflowGroup :one
SELECT GROUP_CONCAT(p.name SEPARATOR '/') FROM(
        SELECT parent.name
        FROM workflow_groups AS node,
             workflow_groups AS parent
        WHERE parent.workspace_id = ?
          AND node.id = ?
          AND node.left_bower
              BETWEEN parent.left_bower AND parent.right_bower
        ORDER BY parent.left_bower ASC
        LIMIT 10
        OFFSET 1
) AS p
`

type GetFullPathOfWorkflowGroupParams struct {
	WorkspaceID string
	ID          int64
}

func (q *Queries) GetFullPathOfWorkflowGroup(ctx context.Context, arg GetFullPathOfWorkflowGroupParams) (sql.NullString, error) {
	row := q.queryRow(ctx, q.getFullPathOfWorkflowGroupStmt, getFullPathOfWorkflowGroup, arg.WorkspaceID, arg.ID)
	var group_concat sql.NullString
	err := row.Scan(&group_concat)
	return group_concat, err
}

const getNextWorkflowGroupsByKeyword = `-- name: GetNextWorkflowGroupsByKeyword :many
SELECT workspace_id, id, parent_id, name, left_bower, right_bower, workflow_count, h_level, version, created_at, updated_at
FROM workflow_groups
WHERE workspace_id=? AND id < ? AND name LIKE ?
ORDER BY id DESC
LIMIT ?
`

type GetNextWorkflowGroupsByKeywordParams struct {
	WorkspaceID string
	ID          int64
	Name        string
	Limit       int32
}

func (q *Queries) GetNextWorkflowGroupsByKeyword(ctx context.Context, arg GetNextWorkflowGroupsByKeywordParams) ([]WorkflowGroup, error) {
	rows, err := q.query(ctx, q.getNextWorkflowGroupsByKeywordStmt, getNextWorkflowGroupsByKeyword,
		arg.WorkspaceID,
		arg.ID,
		arg.Name,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowGroup
	for rows.Next() {
		var i WorkflowGroup
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.ParentID,
			&i.Name,
			&i.LeftBower,
			&i.RightBower,
			&i.WorkflowCount,
			&i.HLevel,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPreviousWorkflowGroupsByKeyword = `-- name: GetPreviousWorkflowGroupsByKeyword :many
SELECT workspace_id, id, parent_id, name, left_bower, right_bower, workflow_count, h_level, version, created_at, updated_at
FROM workflow_groups
WHERE workspace_id=? AND id > ? AND name LIKE ?
ORDER BY id ASC
LIMIT ?
`

type GetPreviousWorkflowGroupsByKeywordParams struct {
	WorkspaceID string
	ID          int64
	Name        string
	Limit       int32
}

func (q *Queries) GetPreviousWorkflowGroupsByKeyword(ctx context.Context, arg GetPreviousWorkflowGroupsByKeywordParams) ([]WorkflowGroup, error) {
	rows, err := q.query(ctx, q.getPreviousWorkflowGroupsByKeywordStmt, getPreviousWorkflowGroupsByKeyword,
		arg.WorkspaceID,
		arg.ID,
		arg.Name,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowGroup
	for rows.Next() {
		var i WorkflowGroup
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.ParentID,
			&i.Name,
			&i.LeftBower,
			&i.RightBower,
			&i.WorkflowCount,
			&i.HLevel,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRangeWorkflowGroups = `-- name: GetRangeWorkflowGroups :many
SELECT workspace_id, id, parent_id, name, left_bower, right_bower, workflow_count, h_level, version, created_at, updated_at
FROM workflow_groups
WHERE workspace_id=? AND left_bower > ? AND right_bower < ?
ORDER BY left_bower ASC
`

type GetRangeWorkflowGroupsParams struct {
	WorkspaceID string
	LeftBower   int16
	RightBower  int16
}

func (q *Queries) GetRangeWorkflowGroups(ctx context.Context, arg GetRangeWorkflowGroupsParams) ([]WorkflowGroup, error) {
	rows, err := q.query(ctx, q.getRangeWorkflowGroupsStmt, getRangeWorkflowGroups, arg.WorkspaceID, arg.LeftBower, arg.RightBower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowGroup
	for rows.Next() {
		var i WorkflowGroup
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.ParentID,
			&i.Name,
			&i.LeftBower,
			&i.RightBower,
			&i.WorkflowCount,
			&i.HLevel,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRootWorkflowGroup = `-- name: GetRootWorkflowGroup :one
SELECT workspace_id, id, parent_id, name, left_bower, right_bower, workflow_count, h_level, version, created_at, updated_at
FROM workflow_groups
WHERE workspace_id=? AND parent_id=0 LIMIT 1
`

func (q *Queries) GetRootWorkflowGroup(ctx context.Context, workspaceID string) (WorkflowGroup, error) {
	row := q.queryRow(ctx, q.getRootWorkflowGroupStmt, getRootWorkflowGroup, workspaceID)
	var i WorkflowGroup
	err := row.Scan(
		&i.WorkspaceID,
		&i.ID,
		&i.ParentID,
		&i.Name,
		&i.LeftBower,
		&i.RightBower,
		&i.WorkflowCount,
		&i.HLevel,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRootWorkflowGroupsForUpdate = `-- name: GetRootWorkflowGroupsForUpdate :many
SELECT workspace_id, id, parent_id, name, left_bower, right_bower, workflow_count, h_level, version, created_at, updated_at
FROM workflow_groups
WHERE workspace_id = ? FOR UPDATE
`

func (q *Queries) GetRootWorkflowGroupsForUpdate(ctx context.Context, workspaceID string) ([]WorkflowGroup, error) {
	rows, err := q.query(ctx, q.getRootWorkflowGroupsForUpdateStmt, getRootWorkflowGroupsForUpdate, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowGroup
	for rows.Next() {
		var i WorkflowGroup
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.ParentID,
			&i.Name,
			&i.LeftBower,
			&i.RightBower,
			&i.WorkflowCount,
			&i.HLevel,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkflowGroup = `-- name: GetWorkflowGroup :one
SELECT workspace_id, id, parent_id, name, left_bower, right_bower, workflow_count, h_level, version, created_at, updated_at
FROM workflow_groups
WHERE workspace_id=? AND id=? LIMIT 1
`

type GetWorkflowGroupParams struct {
	WorkspaceID string
	ID          int64
}

func (q *Queries) GetWorkflowGroup(ctx context.Context, arg GetWorkflowGroupParams) (WorkflowGroup, error) {
	row := q.queryRow(ctx, q.getWorkflowGroupStmt, getWorkflowGroup, arg.WorkspaceID, arg.ID)
	var i WorkflowGroup
	err := row.Scan(
		&i.WorkspaceID,
		&i.ID,
		&i.ParentID,
		&i.Name,
		&i.LeftBower,
		&i.RightBower,
		&i.WorkflowCount,
		&i.HLevel,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorkflowGroups = `-- name: GetWorkflowGroups :many
SELECT workspace_id, id, parent_id, name, left_bower, right_bower, workflow_count, h_level, version, created_at, updated_at
FROM workflow_groups
WHERE workspace_id=?
`

func (q *Queries) GetWorkflowGroups(ctx context.Context, workspaceID string) ([]WorkflowGroup, error) {
	rows, err := q.query(ctx, q.getWorkflowGroupsStmt, getWorkflowGroups, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowGroup
	for rows.Next() {
		var i WorkflowGroup
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.ParentID,
			&i.Name,
			&i.LeftBower,
			&i.RightBower,
			&i.WorkflowCount,
			&i.HLevel,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkflowGroupsByKeyword = `-- name: GetWorkflowGroupsByKeyword :many
SELECT workspace_id, id, parent_id, name, left_bower, right_bower, workflow_count, h_level, version, created_at, updated_at
FROM workflow_groups
WHERE workspace_id=? AND name LIKE ?
ORDER BY id DESC
LIMIT ?
`

type GetWorkflowGroupsByKeywordParams struct {
	WorkspaceID string
	Name        string
	Limit       int32
}

func (q *Queries) GetWorkflowGroupsByKeyword(ctx context.Context, arg GetWorkflowGroupsByKeywordParams) ([]WorkflowGroup, error) {
	rows, err := q.query(ctx, q.getWorkflowGroupsByKeywordStmt, getWorkflowGroupsByKeyword, arg.WorkspaceID, arg.Name, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowGroup
	for rows.Next() {
		var i WorkflowGroup
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.ParentID,
			&i.Name,
			&i.LeftBower,
			&i.RightBower,
			&i.WorkflowCount,
			&i.HLevel,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
