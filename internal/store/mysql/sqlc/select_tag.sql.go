// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: select_tag.sql

package sqlc

import (
	"context"
)

const getTag = `-- name: GetTag :one
SELECT workspace_id, id, name, hash_name, color_src, icon_src, description, is_published, version, is_deleted, created_by, updated_by, created_at, updated_at
FROM tags
WHERE workspace_id=? AND id=? LIMIT 1
`

type GetTagParams struct {
	WorkspaceID string
	ID          int64
}

func (q *Queries) GetTag(ctx context.Context, arg GetTagParams) (Tag, error) {
	row := q.queryRow(ctx, q.getTagStmt, getTag, arg.WorkspaceID, arg.ID)
	var i Tag
	err := row.Scan(
		&i.WorkspaceID,
		&i.ID,
		&i.Name,
		&i.HashName,
		&i.ColorSrc,
		&i.IconSrc,
		&i.Description,
		&i.IsPublished,
		&i.Version,
		&i.IsDeleted,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTagSearchByName = `-- name: GetTagSearchByName :many
SELECT workspace_id, id, name, hash_name, color_src, icon_src, description, is_published, version, is_deleted, created_by, updated_by, created_at, updated_at
FROM tags
WHERE workspace_id=? AND name LIKE ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetTagSearchByNameParams struct {
	WorkspaceID string
	Name        string
	Limit       int32
	Offset      int32
}

func (q *Queries) GetTagSearchByName(ctx context.Context, arg GetTagSearchByNameParams) ([]Tag, error) {
	rows, err := q.query(ctx, q.getTagSearchByNameStmt, getTagSearchByName,
		arg.WorkspaceID,
		arg.Name,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.Name,
			&i.HashName,
			&i.ColorSrc,
			&i.IconSrc,
			&i.Description,
			&i.IsPublished,
			&i.Version,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagSearchByNameWithPublished = `-- name: GetTagSearchByNameWithPublished :many
SELECT workspace_id, id, name, hash_name, color_src, icon_src, description, is_published, version, is_deleted, created_by, updated_by, created_at, updated_at
FROM tags
WHERE workspace_id=? AND name LIKE ? AND is_published=?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetTagSearchByNameWithPublishedParams struct {
	WorkspaceID string
	Name        string
	IsPublished bool
	Limit       int32
	Offset      int32
}

func (q *Queries) GetTagSearchByNameWithPublished(ctx context.Context, arg GetTagSearchByNameWithPublishedParams) ([]Tag, error) {
	rows, err := q.query(ctx, q.getTagSearchByNameWithPublishedStmt, getTagSearchByNameWithPublished,
		arg.WorkspaceID,
		arg.Name,
		arg.IsPublished,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.Name,
			&i.HashName,
			&i.ColorSrc,
			&i.IconSrc,
			&i.Description,
			&i.IsPublished,
			&i.Version,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagWithPublished = `-- name: GetTagWithPublished :many
SELECT workspace_id, id, name, hash_name, color_src, icon_src, description, is_published, version, is_deleted, created_by, updated_by, created_at, updated_at
FROM tags
WHERE workspace_id=? AND is_published=?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetTagWithPublishedParams struct {
	WorkspaceID string
	IsPublished bool
	Limit       int32
	Offset      int32
}

func (q *Queries) GetTagWithPublished(ctx context.Context, arg GetTagWithPublishedParams) ([]Tag, error) {
	rows, err := q.query(ctx, q.getTagWithPublishedStmt, getTagWithPublished,
		arg.WorkspaceID,
		arg.IsPublished,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.Name,
			&i.HashName,
			&i.ColorSrc,
			&i.IconSrc,
			&i.Description,
			&i.IsPublished,
			&i.Version,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsByWorkflowID = `-- name: GetTagsByWorkflowID :many
SELECT t.workspace_id, t.id, t.name, t.hash_name, t.color_src, t.icon_src, t.description, t.is_published, t.version, t.is_deleted, t.created_by, t.updated_by, t.created_at, t.updated_at
FROM tags AS t
    JOIN tag_workflows AS tw
        ON tw.workspace_id = t.workspace_id
        AND tw.tag_id = t.id
WHERE tw.workspace_id = ?
  AND (tw.workflow_id = ? OR tw.workflow_id = 0)
  AND t.is_deleted = false
  AND t.is_published = true
`

type GetTagsByWorkflowIDParams struct {
	WorkspaceID string
	WorkflowID  int64
}

func (q *Queries) GetTagsByWorkflowID(ctx context.Context, arg GetTagsByWorkflowIDParams) ([]Tag, error) {
	rows, err := q.query(ctx, q.getTagsByWorkflowIDStmt, getTagsByWorkflowID, arg.WorkspaceID, arg.WorkflowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.Name,
			&i.HashName,
			&i.ColorSrc,
			&i.IconSrc,
			&i.Description,
			&i.IsPublished,
			&i.Version,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsSortByName = `-- name: GetTagsSortByName :many
SELECT workspace_id, id, name, hash_name, color_src, icon_src, description, is_published, version, is_deleted, created_by, updated_by, created_at, updated_at
FROM tags
WHERE workspace_id=? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type GetTagsSortByNameParams struct {
	WorkspaceID string
	Limit       int32
	Offset      int32
}

func (q *Queries) GetTagsSortByName(ctx context.Context, arg GetTagsSortByNameParams) ([]Tag, error) {
	rows, err := q.query(ctx, q.getTagsSortByNameStmt, getTagsSortByName, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.ID,
			&i.Name,
			&i.HashName,
			&i.ColorSrc,
			&i.IconSrc,
			&i.Description,
			&i.IsPublished,
			&i.Version,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
