// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: select_tag_workflows.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const getTagWorkflows = `-- name: GetTagWorkflows :many
SELECT t.created_at, t.updated_at, t.workspace_id, tag_id, workflow_id, wf.workspace_id, workflow_group_id, id, name, color_src, icon_src, description, prefix_id, state, created_by, updated_by, is_published, wf.created_at, wf.updated_at FROM tag_workflows AS t JOIN workflows AS wf ON t.workflow_id=wf.id
WHERE t.workspace_id=? AND t.tag_id=?
`

type GetTagWorkflowsParams struct {
	WorkspaceID string
	TagID       int64
}

type GetTagWorkflowsRow struct {
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
	WorkspaceID     string
	TagID           int64
	WorkflowID      int64
	WorkspaceID_2   string
	WorkflowGroupID int64
	ID              int64
	Name            string
	ColorSrc        string
	IconSrc         string
	Description     string
	PrefixID        int64
	State           int8
	CreatedBy       int64
	UpdatedBy       int64
	IsPublished     bool
	CreatedAt_2     time.Time
	UpdatedAt_2     time.Time
}

func (q *Queries) GetTagWorkflows(ctx context.Context, arg GetTagWorkflowsParams) ([]GetTagWorkflowsRow, error) {
	rows, err := q.query(ctx, q.getTagWorkflowsStmt, getTagWorkflows, arg.WorkspaceID, arg.TagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagWorkflowsRow
	for rows.Next() {
		var i GetTagWorkflowsRow
		if err := rows.Scan(
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WorkspaceID,
			&i.TagID,
			&i.WorkflowID,
			&i.WorkspaceID_2,
			&i.WorkflowGroupID,
			&i.ID,
			&i.Name,
			&i.ColorSrc,
			&i.IconSrc,
			&i.Description,
			&i.PrefixID,
			&i.State,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.IsPublished,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
